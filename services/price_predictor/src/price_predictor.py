from pydantic import BaseModel
from src.config import config, comet_config, CometConfig
from src.hopsworks_api import push_value_to_feature_group
from src.model_registry import get_model_name
import json
import os
from comet_ml.api import API
import joblib
from src.ohlc_data_reader import OhlcDataReader
from src.config import HopsworksConfig, hopsworks_config
from loguru import logger

class PricePrediction(BaseModel):
    timestamp_ms: int
    product_id: str
    price: float

class PricePredictor:
    def __init__(
        self, 
        product_id: str,
        ohlc_window_sec: int, 
        forecast_steps: int,
        feature_view_name: str,
        feature_view_version: int,
        last_n_minutes: int,
        features_to_use: list[str],
        model_path: str,
    ):
        self.product_id = product_id
        self.ohlc_window_sec = ohlc_window_sec
        self.forecast_steps = forecast_steps
        self.feature_view_name = feature_view_name
        self.feature_view_version = feature_view_version
        self.last_n_minutes = last_n_minutes
        self.features_to_use = features_to_use
        self.model_path = model_path

        # Load the model from the model registry
        logger.info(f"Loading model from {model_path}")
        self.model = self._load_model_from_disk(model_path)

        # create my OHLC data reader
        logger.info("Creating OHLC data reader and establishing connection to the feature store")
        self.ohlc_data_reader = OhlcDataReader(
            ohlc_window_sec=self.ohlc_window_sec,
            hopsworks_config=hopsworks_config,
            feature_view_name=self.feature_view_name,
            feature_view_version=self.feature_view_version,
        )

    def _load_model_from_disk(self, model_path: str) -> "Model":
        return joblib.load(model_path)

    @classmethod
    def from_model_registry(
            cls, 
            product_id: str, 
            ohlc_window_sec: int,
            forecast_steps: int,
            status: str,
    ) -> 'Predictor':
        """
        Fetches the model artifact from the model registry, and all the relevant
        metadata we need to make predictions from this model artifact, and return a
        Predictor object.

        Steps:
        1. Load the model artifact from the model registry
        2. Fetch the relevant metadata from the model registry
        3. Return a Predictor object with the model artifact and the metadata

        Args:
            - product_id: the product_id of the model we want to fetch
            - status: the status of the model we want to fetch, for example "production"

        Returns:
            - Predictor: an instance of the Predictor class with the model artifact and
            the metadata fetched from the model registry
        """
        comet_api = API(api_key=comet_config.comet_api_key)

        # Step 1: Download the model artifact from the model registry
        model = comet_api.get_model(
            workspace=comet_config.comet_workspace,
            model_name=get_model_name(product_id, ohlc_window_sec, forecast_steps),
        )
        # find the version for the current model with the given `status`
        # Here I am assuming there is only one model version for that status.
        # I recommend you only have 1 production model at a time.
        # As for dev, or staging, you can have multiple versions, so we sort by
        # version and get the latest one.
        model_versions = model.find_versions(status=status)
        # sort the model versions list from high to low and pick the first element
        model_version = sorted(model_versions, reverse=True)[0]

        # download the model artifact for this `model_version`
        model.download(version=model_version, output_folder='./')
        # TODO: this name should be generated by the same function, that I call in the training pipeline
        model_path = f'./{get_model_name(product_id, ohlc_window_sec, forecast_steps)}.joblib'

        # Step 2: Fetch the relevant metadata from the model registry
        # find the experiment associated with this model
        experiment_key = model.get_details(version=model_version)['experimentKey']

        # get the experiment
        experiment = comet_api.get_experiment_by_key(experiment_key)

        # get all the parameters I need from the experiment
        # - feature_view_name: str,
        # - feature_view_version: int,
        # - last_n_minutes: int,
        # - features_to_use: List[str],

        # Use comment ML to get the parameters from the experiment
        feature_view_name = experiment.get_parameters_summary('feature_view_name')[
            'valueCurrent'
        ]
        feature_view_version = int(
            experiment.get_parameters_summary('feature_view_version')['valueCurrent']
        )
        last_n_minutes = int(experiment.get_parameters_summary('last_n_minutes')['valueCurrent'])

        features_to_use = json.loads(
            experiment.get_parameters_summary('features_to_use')['valueCurrent']
        )

        # Step 3: Return a Predictor object with the model artifact and the metadata
        return cls(
            model_path=model_path,
            product_id=product_id,
            ohlc_window_sec=ohlc_window_sec,
            forecast_steps=forecast_steps,
            feature_view_name=feature_view_name,
            feature_view_version=feature_view_version,
            last_n_minutes=last_n_minutes,
            features_to_use=features_to_use,
        )

    def predict(self) -> PricePrediction:
        """
        Fetches OHLCV candels from the online feature group for the last self.last_n_minutes
        and makes a prediction for the next self.forecast_steps minutes
        """
        # read the data from the online feature group
        ohlc_data = self.ohlc_data_reader.read_from_online_store(
            product_id=self.product_id,
            last_n_minutes=self.last_n_minutes,
        )
        logger.info(f"Read {len(ohlc_data)} OHLCV candles from the online feature group")

        # make a prediction
        prediction = self.model.predict(ohlc_data)

        # Code to generate a prediction
        print("Generating prediction...")

        # For now, we will just return a dummy prediction
        return PricePrediction(
            timestamp_ms=123456789,
            product_id=self.product_id,
            price=123.45
        )

    def _load_model_from_registry(self) -> "Model":
        pass

    def save_prediction(self, prediction):
        """Saves the prediction to the online feature group
        """
        # Code to save the prediction
        print("Saving prediction...")

